
1 1 +
 2
10 10 x
 100
exch
 2
/
 50
8 /
 6.25
int
 6
lx
 6.25
frac
 0.25
-
 5.75
P
 5.75
pi
 3.14159
P
 5.75
 3.14159
%
 2.60841
11 4 %
 3
1-
 2
10 **
 1,024
2 >>
 256
4 <<
 4,096

.
 error: unrecognized input '.'
. mode
 error: unrecognized input '. mode'
foobar 12
 error: unrecognized input 'foobar 12'
2 ..3
 error: unrecognized input '..3'
pop
 4,096

H
 0x2     # warning: accuracy lost, was 2.60840734641020676
 0x1000
 Mode is hex.  Integer math with 64 bits.
0xfffff
0xaaaaa ~ &
 0x5,5555
lastx |
 0xffff,ffff,fff5,5555
20 width
 Integers are now 20 bits wide.
 0x5,5555
clear
0xfffff
0xaaaaa ~ &
 0x5,5555
lastx ~ |
 0xf,ffff
0x10101010 xor
 0xf,efef
d
 -4,113
chs
 0x1011
d
 4,113
clear
F
 Mode is float.  Displaying 6 digits of total precision.
3
recip
 0.333333
sqrt
 0.57735
push
 0.57735
recip
 1.73205
*
 1
asin
 90
1 +
 91
cos
 -0.0174524
0 degrees
 trig functions will now use radians
 -0.0174524
acos 180 * pi /
 91
1 degrees
 trig functions will now use degrees
 91
cos
 -0.0174524
1 degrees
 trig functions will now use degrees
 -0.0174524
lastx +
 90.9825
frac
 0.982548
store
 0.982548
1 i2mm
 25.4
km2mi
 15.7828
15k
 Will show 15 significant digits.
 15.78282848
oz2g
 447.43529599376
g2oz
 15.78282848
l2q
 16.6775570265312
c2f
 62.0196026477562
o
 076     # warning: display format loses accuracy
h
 0x3e     # warning: display format loses accuracy
0xf0 +
 302.019602647756
H
 0x0     # warning: accuracy lost, was 0.982547593562716898
 0x12e     # warning: accuracy lost, was 302.019602647756157
 Mode is hex.  Integer math with 20 bits.
0xf00 |
 0xf2e
4 <<
 0xf2e0
12 width
 Integers are now 12 bits wide.
 0x2e0
4 >>
 0x2e
0xf00 |
 0xf2e
d
 -210
2 +
 0xf30
d
 -208
100 +
 0xf94
200 +
 0x5c
clear
64w
 Integers are now 64 bits wide.
0x8765
o
 0103,545
16 <<
 0x8765,0000
h
 0x8765,0000
b
 0b00000000,00000000,00000000,00000000,10000111,01100101,00000000,00000000
0 groups
 Numeric grouping is now off
 0x87650000
16w
 Integers are now 16 bits wide.
 0x0
h
 0x0
B
 0b0000000000000000
 Mode is binary.  Integer math with 16 bits.
1g
 Numeric grouping is now on
 0b00000000,00000000
b
 0b00000000,00000000
D
 0
 Mode is signed decimal.  Integer math with 16 bits.
32w
 Integers are now 32 bits wide.
 0
h
 0x0
0x8765,0000

F
 0
 -2,023,424,000
 Mode is float.  Displaying 15 digits of total precision.
pi 100,000 *
 314,159.265358979
H
 0x0
 0x8765,0000
 0x4,cb2f     # warning: accuracy lost, was 314159.265358979324
 Mode is hex.  Integer math with 32 bits.
D
 0
 -2,023,424,000
 314,159
 Mode is signed decimal.  Integer math with 32 bits.
0g
 Numeric grouping is now off
 314159

# comment test
clear H  # comment test
 Mode is hex.  Integer math with 32 bits.
0x7fffffff#ffff
chs
 0x80000001
chs
 0x7fffffff
1 +
 0x80000000
chs
 0x80000000
1 +
 0x80000001
chs
 0x7fffffff

24 clearb 
 0x7effffff

O
 017677777777
 Mode is octal.  Integer math with 32 bits.
~
 020100000000
h
 0x81000000
1 groups
 Numeric grouping is now on
 020,100,000,000
h
 0x8100,0000
~
 017,677,777,777
dup
 017,677,777,777
O
 017,677,777,777
 017,677,777,777
 Mode is octal.  Integer math with 32 bits.
h
 0x7eff,ffff
16 <<
 037,777,600,000
h
 0xffff,0000
16 <<
 00
exch
 017,677,777,777
32 <<
 00
clear
F
 Mode is float.  Displaying 15 digits of total precision.
32k
 Will show the maximum of 18 significant digits.
pi
 3.14159265358979324
frac
 0.14159265358979324
pi
 3.14159265358979324
chs
 -3.14159265358979324
frac
 -0.14159265358979324
pi
 3.14159265358979324
int
 3
pi
 3.14159265358979324
chs
 -3.14159265358979324
int
 -3
pi
 3.14159265358979324
15k
 Will show 15 significant digits.
 3.14159265358979
pi
 3.14159265358979
10 15 ^ *
 3.14159265358979e+15
15K
 Will show at most 15 digits after the decimal.
 3,141,592,653,589,793.24
5K
 Will show at most 5 digits after the decimal.
 3,141,592,653,589,793.24
1K
 Will show at most 1 digit after the decimal.
 3,141,592,653,589,793.2
0K
 Will show no digits after the decimal.
 3,141,592,653,589,793
15k
 Will show 15 significant digits.
 3.14159265358979e+15
1k
 Will show 1 significant digit.
 3e+15
10k
 Will show 10 significant digits.
 3.141592654e+15
d
 3,141,592,653,589,793     # warning: display format loses accuracy
f
 3.141592654e+15
pi
 3.141592654
10 15 ** *
 3.141592654e+15
-
 0

# test the sum command
clear
1 2 3 4 5
sum
 15
1 2
0 mark
 2
3 4 5
sum
 12
0 mark
 12
26 34
+
 60
P
 15
 1
 2
 12
 60
sum
 60
sum
 90
1 2 3 4 5 6 7 8 9 3mark sum
 24
2 mark 17 18 19
sum
 84

clear
-1 5 *
 -5
-10 -20 /
 0.5
( 1 + 2 )
 3
(3 + 4 * 5)
 23
(7 - 4 + 2)
 5
(10 - 2 - 3 )
 5
(3 - 4 -2)
 error: bad expression sequence, last saw +4 and -2
(6 / 2 * 3 )
 9
(8 % 3 + 2 )
 4
(3/4/2)
 0.375
(5|2&1)
 5
(4 << 1 + 1)
 16
(1 || 0 && 0)
 1
(-3 + 5)
 2
(6 * -2)
 -12
(( 5 + 4) - 2)
 7
( -3 ** 2 )
 9
( pi - 1 )
 2.141592654
((3 + 4) * 5)
 35
((8 / (2 * 2)))
 2
(3- -2)
 5
-3 log2
 nan
(log10 -4)
 nan
==
 0
(2 ^ 3 ^ 2)
 512
(8 / (3 - 3))
 inf
0invalidok
 error: unrecognized input 'invalidok'
pop
 inf
(8 / (3 - 3))
 inf
(4 + 5)
 9
(4 + * 5)
 error: bad operator sequence, last saw oper + and oper *
(4 + 5 6)
 error: bad expression sequence, last saw +5 and +6
(4 + (5 + 6
 error: missing parentheses
 9
(4 + (5 + 6)) - 7)
 warning: mismatched/extra parentheses
 7
(3 setb 2)
 7
(0xff clearb 3) h
 0xf7
(3 xor 1 )
 2
( 3 + 4 x 2 / ( 1 - 5 ) ** 2 ** 3 )
 3.00012207
((2+3)*4**2)
 error: bad expression sequence, last saw +2 and +3
((2 + 3)*4**2)
 80
((0x5 & 8) && 1)
 0
((0x5 & 4) && 1)
 1
((0x5 & 4) <= pi)
 0
((0x5 & 1) <= pi)
 1
(23 - 7 == 1 << 4)
 1
( 1 < 3 && 2 > .4 && 100.1 <= 100.0 )
 0
( 1 < 3 && 2 > .4 && 100.1 <= 100.12 )
 1
( 5 & 0xff == 255 )
 0
( 5 & (0xff == 255) )
 1
( 4 & (0xff == 255) )
 0

3K
 Will show at most 3 digits after the decimal.
 0.000

25 tan
 0.466
atan
 25.000

-25 tan
 -0.466
atan
 -25.000

115 tan
 -2.145
atan
 -65.000

-115 tan
 2.145
atan
 65.000


25 tan
 0.466
10 * 10 atan2
 25.000

-25 tan
 -0.466
10 x 10 atan2
 -25.000

115 tan
 -2.145
10 * 10 atan2
 -65.000

-115 tan
 2.145
10 * 10 atan2
 65.000


25 tan
 0.466
10 * 10 atan2
 25.000

-25 tan
 -0.466
10 x 10 atan2
 -25.000

115 tan
 -2.145
10 chs * 10 chs atan2
 115.000

-115 tan
 2.145
10 chs * 10 chs atan2
 -115.000
7k
 Will show 7 significant digits.
 -115
( i2mm -.75 )
 -19.05
40 i2mm
 1,016
0 g
 Numeric grouping is now off
 1016
3K
 Will show at most 3 digits after the decimal.
 1016.000
1 g
 Numeric grouping is now on
 1,016.000
clear
H
 Mode is hex.  Integer math with 32 bits.
16w
 Integers are now 16 bits wide.
0xffff
d
 -1
u
 65,535
32w
 Integers are now 32 bits wide.
 0xffff,ffff
d
 -1
u
 4,294,967,295
0xffff &
 0xffff
d
 65,535
u
 65,535
16w
 Integers are now 16 bits wide.
 0xffff
d
 -1
u
 65,535
2w
 Integers are now 2 bits wide.
 0x3
p
 0x3
d
 -1
u
 3
1 -
 0x2
d
 -2
u
 2
1-
 0x1
d
 1
u
 1
1-
 0x0
~
 0x3
clear
F 6k
 Will show 6 significant digits.
10 10000 ^
 inf
10 -10000 ^
 0
1 0 / s1
 inf
-1 0 / s2
 -inf
-2 log10 s3
 nan
#
# The comments below are taken directly from the powl() man page.
# The x and y they refer to, i.e. powl(x, y), are expressed in the
# same order in RPN notation, but rca would normally call them "y x ^"
#
# If x is +0 or -0, and y is less than 0 and not an odd
# integer, a pole error occurs and +HUGE_VAL, +HUGE_VALF, or
# +HUGE_VALL, is returned.
0 -2 ^
 inf
-0 -2 ^
 inf
# If x is +0 (-0), and y is an odd integer greater than 0, the
# result is +0 (-0).
0 3 ^
 0
-0 3 ^
 -0
# If x is 0, and y greater than 0 and not an odd integer, the
# result is +0.
0 2 ^
 0
# If x is -1, and y is positive infinity or negative infinity,
# the result is 1.0.
-1 r1 ^
 1
-1 r2 ^
 1
# If x is +1, the result is 1.0 (even if y is a NaN).
1 r3 ^
 1
# If y is 0, the result is 1.0 (even if x is a NaN).
r3 0 ^
 1
# If x is a finite value less than 0, and y is a finite
# noninteger, a domain error occurs, and a NaN is returned.
-1 .5 ^
 -nan
-2 2.5 ^
 -nan
# If the absolute value of x is less than 1, and y is negative
# infinity, the result is positive infinity.
.3 r2 ^
 inf
# If the absolute value of x is greater than 1, and y is negative
# infinity, the result is +0.
-2 r2 ^
 0
# If the absolute value of x is less than 1, and y is positive
# infinity, the result is +0.
.5 r1 ^
 0
-.4 r1 ^
 0
# If the absolute value of x is greater than 1, and y is positive
# infinity, the result is positive infinity.
-3 r1 ^
 inf
# If x is negative infinity, and y is an odd integer less than 0,
# the result is -0.
r2 -3 ^
 -0
# If x is negative infinity, and y less than 0 and not an odd
# integer, the result is +0.
r2 -2 **
 0
# If x is negative infinity, and y is an odd integer greater than
# 0, the result is negative infinity.
r2 3 ^
 -inf
# If x is negative infinity, and y greater than 0 and not an odd
# integer, the result is positive infinity.
r2 4 ^
 inf
# If x is positive infinity, and y less than 0, the result is +0.
r1 -1 ^
 0
r1 -.5 ^
 0
# If x is positive infinity, and y greater than 0, the result is
# positive infinity.
r1 2 ^
 inf
r1 .5 ^
 inf
# end of powl(), tests above.
# start of atan2 tests, from man page
clear
0 degrees
 trig functions will now use radians
# If y is +0 (-0) and x is less than 0, +pi (-pi) is returned.
(0 atan2 -1) pi ==
 1
(-0 atan2 -1) (-pi) ==
 1
# If y is +0 (-0) and x is greater than 0, +0 (-0) is returned.
(-0 atan2 2) -0 ==
 1
# If y is less than 0 and x is +0 or -0, -pi/2 is returned.
(-1 atan2 0) (-pi/2) ==
 1
(-1 atan2 -0) (-pi/2) ==
 1

# If y is greater than 0 and x is +0 or -0, pi/2 is returned.
(1 atan2 0) (pi/2) ==
 1
(1 atan2 -0) (pi/2) ==
 1

# If either x or y is NaN, a NaN is returned.
(r3 atan2 0)
 nan
(10 atan2 r3)
 nan

# If y is +0 (-0) and x is -0, +pi (-pi) is returned.
(0 atan2 -0) pi ==
 1
(-0 atan2 -0) (-pi) ==
 1

# If y is +0 (-0) and x is +0, +0 (-0) is returned.
(-0 atan2 0) -0 ==
 1

# If y is a finite value greater (less) than 0, and x is negative  infinity, +pi (-pi) is returned.
(2 atan2 r2) pi ==
 1
(-2 atan2 r2) (-pi) ==
 1

# If y is a finite value greater (less) than 0, and x is positive infinity, +0 (-0) is returned.
(3 atan2 r1) 0 ==
 1
(-3 atan2 r1) -0 ==
 1

# If y is positive infinity (negative infinity), and x  is  finite,  pi/2 (-pi/2) is returned.
(r1 atan2 2) (pi/2) ==
 1
(r2 atan2 2) (-pi/2) ==
 1

# If  y is positive infinity (negative infinity) and x is negative infinity, +3*pi/4 (-3*pi/4) is returned.
(r1 atan2 r2) (3*pi/4) ==
 1
(r2 atan2 r2) (-3*pi/4) ==
 1

# If y is positive infinity (negative infinity) and x is positive  infinity, +pi/4 (-pi/4) is returned.
(r1 atan2 r1) (pi/4) ==
 1
(r2 atan2 r1) (-pi/4) ==
 1

# misc tests follow
clear
0 degrees
 trig functions will now use radians
(tan(pi/2))
 nan
(tan(pi/2 + 1.0842e-19))
 nan
(tan(pi/2 - 1.0842e-19))
 nan
(ln(0))
 -inf
(ln(-1))
 nan
(sqrt(-1))
 -nan
(3 % 0)
 -nan
