.TH rca 1 2025-12-1
.SH NAME
rca \- a rich/RPN (and more) programmer's calculator
.SH SYNOPSIS
.BR rca
.I [ initial rca command text ]

.SH DESCRIPTION
At it's heart, 
.B rca
is a command-line reverse polish notation (RPN) calculator inspired
(very loosely) by the Hewlett-Packard operating model used in their
long line of scientific calculators.  Operators include
scientific, logical, and bitwise operators.  Word width can be
limited, for working with programs for any class of CPU.  In addition,
.B rca
can evaluate traditional infix expressions, greatly expanding its
usefulness.  Input is free form, for the most part, and
.B rca
is easily incorporated into shell scripts to provide floating point
support.  Whitespace is usually optional, though there may be cases where ambiguity
would get in the way.  Any text including and following a
.B #
character will be ignored as a comment.

.SH REVERSE POLISH NOTATION
Numbers entered by the user are pushed onto a stack.  Operators pop
those stack entries, usually 1 or 2 at a time, and push the result of
the operation back on the stack.  Operators exist which cover the
usual arithemetic operations
.RB ( + ,
.BR - ,
etc),
as well as functions (e.g.,
.BR sin ,
.BR cos ,
.BR sqrt ),
bit-shifting 
.RB ( <<
and
.BR >>),
logical operations 
.RB ( && ,
.BR || ),
and comparators
.RB ( == ,
.BR !=,
.BR <=,
etc).  There are also a few unit conversions available (e.g.,
.BR i2mm ,
.BR oz2g ,
.BR f2c ).
A complete list of operators can be obtained with the
.B ?
or
.B help
commands.  The top two elements on the stack, in HP tradition, are
sometimes referred to as 
.I x
and
.IR y .

.SH INFIX NOTATION
.B rca
supports infix style expressions (i.e., non-RPN expressions).  Such
expressions must be fully enclosed in parentheses, and cannot
cross to a new line.  A single line of input can be a mix of RPN notation
(unparenthesized) and complete infix expressions (parenthesized).
The infix expressions "escape" the RPN model, and are evaluated
with the typical rules of operator precedence (see
.B OPERATOR PRECEDENCE
below).  All input number formats are accepted in infix, just as in RPN.
.P
All
.B rca
stack operators can be used as infix functions, including
the unary operators (i.e.,
.BR - x
.BR + x
.BR ~ x
.BR ! x),
and all of the comparison,
logical, and bitwise operators.  Infix expressions result in a value.  For
example, the expression
.B (-3 + +5)
will result in "2" being pushed
on the stack.  When single operand operators appear in infix expressions, the
operand will always follow the operator.  With two operand operators,
one operand will appear on either side of the operator.  So exponentiation
would be written as
.B ( 3 ** 2 )
(producing 9 as a result) and
.B (0 setb 3)
will give 8.  The expression
.B (sin 180 == cos 90)
has the value 1, i.e. "true".
.P
The special symbol
.B X
can be used in an infix expression to reference the value of 
.I x
(the top of stack) when the expression was invoked.  (The top of
stack will
.I not
be popped or replaced.)  The five storage locations (accessed with
.B store
or 
.B s2
through
.B s5
can also be
referenced, using
.B r1
through
.BR r5 .
The result of an infix expression, whether it's the result of floating
arithmetic, integer bitwise math, or logical comparison, will be
pushed on the RPN stack.  If an error occurs during evaluation of an
infix expression, evaluation will cease, and the stack will be left as
it was at the point of the error.
.P

.SH OPERATING MODES
.B rca
can be configured (via pseudo-operators, which also get their parameters from
the stack) to operate on floating point numbers, or integers, and to print
results in various ways.

.SS Floating point
In floating point mode (i.e., 
.B F
mode, the default mode on entry), all operations use the full size of
long double.  Printing can be controlled with the
.B precision
.BR ( k )
command which specifies a number of digits for the printf "%g" format, or
by the
.B decimals
.BR ( K )
command, which specifies the number of decimals for the printf "%f" format.
So the value of pi multiplied by 1 million will display as 3.14159e+06
with 
.B 6 k
or as 3,141,592.6535898 with
.B 7
.BR K .

Scientific notation will be used when in 
.B precision
mode as it is in printf's %g:  any time the
exponent is less than -4, or greater than the chosen precision.
.B rca
will prevent you from attempting to print with more than the available
significant digits on the system.  The default
.B precision
value is set based on this limit (18 for most modern PC
architectures), and can't be raised above it.  However, if viewing %f
output (after setting a
.B decimals
value), it's easy to start seeing "unclean" bits if the magnitude of
the number grows beyond the number of significant digits.  The numbers
are really big at that point:  over 1e19 on a modern system.  So just
don't do that -- use %g in those case, which will help somewhat. 

Because digital floating point is inexact, values are sometimes
calculated which are
.I almost
correct (like .99999999999... instead of 1), but not quite.
.B rca
tries to help by snapping very close values to 0, or to adjacent
integers, and by rounding when the precision limits of the floating
point representation are reached.

.SS Integer
Integer mode is selected with any of the following commands, which
also choose, the default display format:
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).
The default printing format is used by
the
.BR p ,
.BR P ,
and
.B autoprint
commands.
Regardless of the default format, individual values can be
viewed at any time in any format by using
.BR f ,
.BR d ,
.BR u ,
.BR h ,
.BR o ,
or
.BR b .
(The full stack can be printed with
.BR F ,
.BR D ,
.BR U ,
.BR H ,
.BR O ,
or
.B B
which also switches to that display mode.)

The input base of a number is independent of the mode, and controlled
entirely by how it is entered:  10, 0xa, 012, and 0b1010 and 1e01 are all
the same value.

By default the width of
.BR rca 's
integers is the maximum supported, but it can be configured to as
few as 2 bits using the
.B width
(or
.BR w )
command.  The maximum supported width will be either the width of the
.I long long
data type, or of the
.I long double
mantissa, whichever is smaller.  This results in 64 bits on most CPU
architectures in 2025.  (An exception:  52 bits on Raspberry Pi
when running a 32 bit OS)

Values will effectively be masked to the chosen word width for both
use and display, whether they are input by the user or result from an
operation.  Arithmetic on the values will be signed.  If floating
operations are used on width-restricted integers, the width
restriction will be ignored.

.SS Punctuation
To aid in reading long digit strings,
.B rca
will by default add commas to numbers it prints.
These can be disabled with the 
.B 0 commas
command.  (Commas will never appear in the fractional part of a
value.)  When enabled, commas will be added to numbers in every base.

In addition, both commas and the "$" currency symbol will be
silently stripped on input, which is convenient when doing arithmetic
on copy/pasted data.

.SH HELP
A complete list of operators/commands can be obtained entering 
.B ?
or
.BR help .
Many operators have two names, and this is indicated in the
.B help
table.  A table showing operator precedence in infix expressions
is available with the
.B precedence
command.

.SH SPECIAL VALUES
The
.B pi
and
.B e
operators push the values of the obvious constants to the stack.

The
.B s1
through
.B s5
operators copy
.I x
to one of 5 off-stack storage locations (without
disturbing the stack).  The
.B r1
through
.B r5
operators recall those values, pushing them onto the stack, and can
also be used in infix expressions to reference those values.
.RB ( store
is synonymous with
.BR s1 ,
and
.B recall
with
.BR r1 .)

A special operator 
.B sum
will pop and add up previous entries on the
stack, stopping when the stack is empty, or when a 
stack marker previously set with the 
.B mark
command is reached. 
The mark would be set before entering the data for a subsequent 
.BR sum,
in order to limit its reach.  
.B sum
is the only operator to consume more than 2 stack elements.

.SH OPERATOR PRECEDENCE
When used as an RPN calculator, operator precedence isn't really
meaningful, since the stack paradigm makes all operators equal in that
regard.  But when evaluating an infix expression, the relative
precedence of operators is important.  The "precedence" command will
give a list, whose output is reproduced here.  Higher numbers denote
higher precedence.

    28   \fB (                                                \fR
    26   \fB ~ chs negate plus !                              \fR
    24   \fB recip sqrt ln log2 log10 abs frac int            \fR
         \fB sin cos tan asin acos atan atan2                 \fR
         \fB i2mm mm2i ft2m m2ft mi2km km2mi f2c c2f          \fR
         \fB oz2g g2oz oz2ml ml2oz q2l l2q                    \fR
    22   \fB ^ **                                             \fR
    20   \fB * x / %                                          \fR
    18   \fB + -                                              \fR
    16   \fB >> <<                                            \fR
    14   \fB & clearb                                         \fR
    12   \fB xor                                              \fR
    10   \fB | setb                                           \fR
    8    \fB < <= > >=                                        \fR
    6    \fB == !=                                            \fR
    4    \fB &&                                               \fR
    2    \fB ||                                               \fR

.SH OPERATOR NOTES
Most operators behave as they are commonly understood to.  A few need
more specific documentation.

.B modulo
is always done in floating point using the C fmodl() library.

.B frac
applied to negaive values will give a negative result.

.SS Associativity
In infix mode exponentiation 
.RB ( ^ or ** )
is right associative.  (
.B (2 ^ 3 ^ 2)
is read as
.B (2 ^ (3 ^ 2))
.)


.SH DATA TYPES and OVERFLOW

All stack values in
.B rca
are stored in
.I long double
format.  This is convenient for a calculator
which will primarily deal with floating point, but can be a problem with
.BR rca 's
mixed model.  Many operations (primarily the bitwise operations, but
also simply working in other bases and word widths) require conversion
to integer.  The
.I long long
type is used in this case; results are
converted back when finished.  If the conversion from
.I long double
to
.I long long
can't be done without loss, a warning is
issued.  This may happen while printing the value in an integer base,
after switching to an integer mode, or while performing a bitwise
operation.  Execution will proceed after the warning unless
.B errorexit
has been enabled.

Also, if "integer-centric" operators are used (bitwise operators,
mostly), the values will be cast to long long and the result will be
cast back to float, which will likely result in the loss of any
exponential and fractional parts of the value.

.SH EXIT STATUS
.B rca
will normally exit with status 0 or 1; a non-zero value 
at the top of the stack causes a shell exit of 0, a 0 at top of stack
causes an exit value of 1.  An exit status of 2 results if the stack
is empty on normal exit.  An exit status of 3 comes from unrecoverable
internal errors (memory allocation, etc).  Operational warnings and
errors are assumed to be useful to the user, and execution proceeds. 
If the
.B errorexit
command has been given, then warnings and errors will result in an
exit status of 4.  This can be useful when
.B rca
is used non-interactively.  (Once given,
.B errorexit
cannot be rescinded.)

.SH SHELL SUPPORT
.B rca
can take initial input from the command line, and returns a reasonable
set of exit codes on either success or failure, so incorporating it
into the shell is straightforward:
\" CODE/ENDCODE preserve text verbatim
.de CODE
.br
.nr saveIN \\n(.i   \" double the backslash when defining a macro
.RS
.nf
.nh
..
.de ENDCODE
.hy
.fi
.RE
.in \\n[saveIN]u    \" 'u' means 'units': do not scale this number 
..
.CODE

# This shell snippet gives simple access to rca's floating point
# capability from a POSIX shell.
#
# After including this code, use lines like this to calculate:
#	foo=$(fe "$bar * pi")
# or like this for a conditional:
#	if fc "(10 * 3) < $foo"; then ...

_RCA_INIT="3K 0commas errorexit"  # $RCA_INIT can override this

_rca_run()    # support routine
{
    output=$(rca "$_RCA_INIT $RCA_INIT" "( $* )" q)
    exitcode=$?

    if [ $exitcode -le 1 ]; then
	echo $output
	return $exitcode
    fi

    echo rca failure: $output >&2
    exit 1
}

fe()	# Evaluate a floating point expression.
{
    _rca_run "$*"
    return 0
}

fc()	 # Evaluate a floating point conditional expression.
{
    _rca_run "$*" >/dev/null
}

.ENDCODE


.SH AUTHOR
Paul Fox created
.B rca
(formerly called "ca") very slowly over a span of decades, starting in 1993.

