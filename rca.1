.TH rca 1 2025-12-1
.SH NAME
rca \- a rich/RPN (and more) programmer's calculator
.SH SYNOPSIS
.BR rca
.I [ initial rca command text ]

.SH DESCRIPTION
At it's heart,
.B rca
is a command-line reverse polish notation (RPN) calculator inspired
(very loosely) by the Hewlett-Packard operating model used in their
long line of scientific calculators.  Operators include
scientific, logical, and bitwise operators.  Word width can be
limited, for working with values from any class of CPU.  In addition,
.B rca
can evaluate traditional infix expressions, greatly expanding its
usefulness.  Input is free form, for the most part, and
.B rca
is easily incorporated into shell scripts to provide floating point
support.  Whitespace is usually optional, though there may be cases
where ambiguity would get in the way.  Any text including and
following a
.B #
character will be ignored as a comment.

The value at the top of the stack can be shown with the
.B p
command, and the entire stack with
.BR P .
Autoprinting (toggled with
.B a
(or
.BR autoprint )
will print the top of the stack after every input line,
(unless the last thing on that line is numeric, which would make
the autoprinted output redundant).

.SH REVERSE POLISH NOTATION
Numbers entered by the user are pushed onto a stack.  Operators pop
those stack entries, usually 1 or 2 at a time, and push the result of
the operation back on the stack.  Operators exist which cover the
usual arithemetic operations
.RB ( + ,
.BR - ,
etc),
as well as functions (e.g.,
.BR sin ,
.BR cos ,
.BR sqrt ),
bit-shifting
.RB ( <<
and
.BR >>),
logical operations
.RB ( && ,
.BR || ),
and comparators
.RB ( == ,
.BR !=,
.BR <=,
etc).  There are also a few unit conversions available (e.g.,
.BR i2mm ,
.BR oz2g ,
.BR f2c ).
A complete list of operators can be obtained with the
.B ?
or
.B help
commands.  The top two elements on the stack, in HP tradition, are
sometimes referred to as
.I x
and
.IR y .

.SH INFIX NOTATION
.B rca
supports infix style expressions (i.e., non-RPN expressions).  Such
expressions must be fully enclosed in parentheses, and cannot cross to
a new line.  (Infix expressions are translated to RPN by an
impementation of Dijkstra's "shunting yard" algorithm, and then
executed as usual.)  A single line of input can be a mix of RPN
notation (unparenthesized) and complete infix expressions
(parenthesized).  The infix expressions "escape" the RPN model, and
are evaluated with fairly typical rules of precedence (see
.B OPERATOR PRECEDENCE
below).  All input number formats are accepted in infix, just as in RPN.
.P
All
.B rca
stack operators can be used as infix functions, including
the unary operators (i.e.,
.BR - x
.BR + x
.BR ~ x
.BR ! x),
and all of the comparison,
logical, and bitwise operators.  Infix expressions result in a value.  For
example, the expression
.B (-3 + +5)
will result in "2" being pushed
on the stack.  When single operand operators appear in infix expressions, the
operand will always follow the operator.  With two operand operators,
one operand will appear on either side of the operator.  So exponentiation
would be written as
.B ( 3 ** 2 )
(producing 9 as a result) and
.B (0 setb 3)
will give 8.  The expression
.B (sin 180 == cos 90)
has the value 1, i.e. "true".
.P
The special symbol
.B X
can be used in an infix expression to reference the value of
.I x
(the top of stack) when the expression was invoked.  (The top of
stack will
.I not
be popped or replaced.) The five storage locations settable (only in
RPN mode) with
.B store
or
.B s1
through
.B s5
can also be
referenced, using
.B r1
through
.BR r5 .
The result of an infix expression will be
pushed on the RPN stack.  If an error occurs during evaluation of an
infix expression, evaluation will cease, and the stack will be left as
it was at the point of the error.

.SH OPERATING MODES
.B rca
can be configured into two modes of operation:  floating point (the default)
using the
.B F
command, and integer, using one of
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).

The difference between the various integer modes lies purely in how
values are displayed by default, but floating point and integer differ
in a few addional ways.  Most math is done in long double, regardless
of mode, but in integer mode all values are masked to the current word
width, and sign extended, if necessary, before being pushed.  (This
will also happen to all stack values at once when switching from floating
point to an integer mode.)

The input base of a number is independent of the mode, and controlled
entirely by how it is entered:  10, 0xa, 012, and 0b1010 and 1e01 are all
the same value.

.SS Floating point
In floating point mode (i.e.,
.B F
mode, the default mode on entry to
.BR rca ),
all operations use the full size of long double.  Printing can be
controlled with the
.B precision
.BR ( k )
command which specifies a number of digits for the printf "%g" format, or
by the
.B decimals
.BR ( K )
command, which specifies the number of decimals for the printf "%f" format.
So the value of pi multiplied by 1 million will display as 3.14159e+06
with
.B 6 k
or as 3,141,592.6535898 with
.B 7
.BR K .

Scientific notation will be used when in
.B precision
mode any time the
exponent is less than -4, or greater than the chosen precision.  (These
choices from directly from printf.)
.B rca
will try to prevent you from printing with more than the available
significant digits on the system.  The default
.B precision
value is set based on this limit (18 digits for most modern PC
architectures), and can't be raised above it.  However, if viewing %f
output (after setting a
.B decimals
value), it's easy to start seeing "unclean" bits if the magnitude of
the number grows beyond the number of significant digits.  The numbers
are really big at that point:  over 1e19 on a modern system.  So just
don't do that -- use %g in those case, which will help somewhat.

Because digital floating point is inexact, values are sometimes
calculated which are
.I almost
correct (like .99999999999... instead of 1), but not quite.
.B rca
tries to help by snapping very close values to 0, or to adjacent
integers, and by rounding when the precision limits of the floating
point representation are reached.

.SS Integer
Integer mode is selected with any of the following commands, which
also choose the default display format:
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).
The default printing format is used by
the
.BR p ,
.BR P ,
and
.B autoprint
commands.
Regardless of the default format, individual values can be
viewed at any time in any format by using
.BR f ,
.BR d ,
.BR u ,
.BR h ,
.BR o ,
or
.BR b .
(The full stack can be printed with
.BR F ,
.BR D ,
.BR U ,
.BR H ,
.BR O ,
or
.B B
which also switches to that display mode.)

By default the width of
.BR rca 's
integers is the maximum supported, but it can be configured to as
few as 2 bits using the
.B width
(or
.BR w )
command.  The maximum supported width will be either the width of the
.I long long
data type, or of the
.I long double
mantissa, whichever is smaller.  This results in 64 bits on most PC
architectures in 2025.  (An exception:  52 bits on Raspberry Pi
when running a 32 bit OS)

Values will be masked to the chosen word width for both
use and display, whether they are input by the user or result from an
operation.  Arithmetic on all values will be signed.  If floating
operations are used on width-restricted integers, the width
restriction will be ignored for the operation, but masking will happen
when storing the result.

.SS Punctuation
To aid in reading long digit strings,
.B rca
will by default add commas to numbers it prints.
These can be toggled with the
.B c
(or
.BR commas )
command.  When enabled, commas will be added to numbers in every base.
(Commas will never appear in the fractional part of a value.)

In addition, both commas and the "$" currency symbol will be
silently stripped on input, which is convenient when doing arithmetic
on copy/pasted data.

.SH HELP
A complete list of operators/commands can be obtained by entering
.B ?
or
.BR help .
Many operators have two names, and this is indicated in the
.B help
table.  A table showing operator precedence in infix expressions
is available with the
.B precedence
command.

If $PAGER is set in the environment, it will be invoked to display
the help text.  Otherwise the text will be displayed directly to the
terminal.

.SH SPECIAL VALUES
The
.B pi
and
.B e
operators push the values of the obvious constants to the stack.

The
.B s1
through
.B s5
operators copy
.I x
to one of 5 off-stack storage locations (without
disturbing the stack).  The
.B r1
through
.B r5
operators recall those values, pushing them onto the stack, and can
also be used in infix expressions to reference those values.
.RB ( store
is synonymous with
.BR s1 ,
and
.B recall
with
.BR r1 .)

.SH OPERATOR PRECEDENCE
When used as an RPN calculator, operator precedence isn't really
meaningful, since the stack paradigm makes all operators equal in that
regard.  But when evaluating an infix expression, the relative
precedence and associativity of operators is important.  The
"precedence" command will give a list, whose output is reproduced
here.  Higher numbers denote higher precedence.  The 'R' flag denotes
operators which are right associative.  All others group left to
right.

 \fR 1      \fB (
 \fR 2   R  \fB atan2 recip sqrt sin cos tan asin acos atan ln log2 log10
 \fR        \fB   abs frac int i2mm mm2i ft2m m2ft mi2km km2mi f2c c2f
 \fR        \fB   oz2g g2oz oz2ml ml2oz q2l l2q
 \fR 3   R  \fB + - \fR   (unary)
 \fR 4   R  \fB ~ chs negate !
 \fR 5   R  \fB ^ **
 \fR 6      \fB * x / %
 \fR 7      \fB + -
 \fR 8      \fB >> <<
 \fR 9      \fB & clearb
 \fR 10     \fB xor
 \fR 11     \fB | setb
 \fR 12     \fB < <= > >=
 \fR 13     \fB == !=
 \fR 14     \fB &&
 \fR 15     \fB ||

.SH OPERATOR NOTES
Most operators behave as they are commonly understood to.  A few need
more specific documentation.
.RS .1
.IP \\(bu
.B modulo
is a floating point operation.  It uses the C fmodl() library.
.IP \\(bu
.B frac
applied to negative values will give a negative result.
.IP \\(bu
In an infix expression, any operator that takes two arguments expects
them to be to the left and right of the operator.  This looks fine in
the case of the symbolic operators (as in
.B 1 + 2
), but for the named
operators it can be odd looking.  To set bit 3 in 0xf0, the expression
looks like
.B (0xf0 setb
.BR 3 ).
.B atan2
works similarly:
.B (sin 30 atan2 cos 30)
will return the result "30".  (In RPN, this would be
.B 30 sin 30 cos
.BR atan2 .)
.IP \\(bu
Trigonometric operations
.RB ( sin ,
.BR cos ,
.BR tan ,
.BR asin ,
.BR acos ,
.BR atan ,
and
.BR atan2 )
are disallowed in integer mode, since they'd make no sense.
.IP \\(bu
Bitwise operations
.RB ( ~
.BR << ,
.BR >> ,
.BR & ,
.BR | ,
.BR xor ,
.BR clearb ,
.B and
.BR setb )
convert their operands to long long first, regardless of mode.  These
operations will (as might be expected) discard fractional parts, and
may discard significant digits, including the sign of the value.
.IP \\(bu
.B sum
will pop and add up previous entries on the
stack, stopping when the stack is empty, or when a
stack marker previously set with the
.B mark
command is reached.
The mark would be set before entering the data for a subsequent
.BR sum,
in order to limit its reach.
.B sum
is the only operator to consume more than 2 stack elements.

.IP \\(bu
The precedence and association of exponentiation
.RB ( ^
or
.BR ** )
is worth calling out,
since implementations vary.  In
.BR rca 's
infix expressions,
exponentation is right associative, and has lower precedence than unary minus.
So each of these lines returns a result of 1 (true):
.RS
.IP
.B ((2 ^ 3 ^ 2) == (2 ^ (3 ^ 2)))
.I # i.e., 512
.IP
.B ((-3 ^ 2) == ((-3) ^ 2)))
.I # i.e., 9
.RE

.RE

.SH DATA TYPES, OVERFLOW, ACCURACY

All stack values in
.B rca
are stored in
.I long double
format.  This is convenient for a calculator
which will primarily deal with floating point, but can be a problem with
.BR rca 's
mixed model.  Many operations (primarily the bitwise operations, but
also simply working in other bases and word widths) require conversion
to integer.  The
.I long long
type is used in this case; results are
converted back when finished.  If the conversion from
.I long double
to
.I long long
can't be done without loss, a warning is
issued.  This may happen while printing the value in an integer base,
after switching to an integer mode, or while performing a bitwise
operation.  Execution will proceed after the warning unless
.B errorexit
has been enabled.

Floating point math by its nature is imprecise.  It's not uncommon for
small rounding errors, and errors introduced by the necessary binary
to decimal conversions, to change values in obvious ways.  Something
that should be 0 may instead have a very tiny value, or two numbers which
should be equal may differ by an insignificant amount.
.B rca
attempts to help by adjusting values pushed on the
stack.  First, values within about 2e-18 of an integer are forced to that.
integer.  Then, values are decimal-rounded to
.BR rca 's
maximum precision (usually 18 digits).

.SH EXIT STATUS
.B rca
will normally exit with status 0 or 1; a non-zero value
at the top of the stack causes a shell exit of 0, a 0 at top of stack
causes an exit value of 1.  An exit status of 2 results if the stack
is empty on normal exit.  An exit status of 3 comes from unrecoverable
internal errors (e.g., failed memory allocation).  Operational warnings and
errors regarding empty stacks and data types are normally assumed to be useful
to the user, and execution proceeds. If the
.B errorexit
command has been given, then warnings and errors will result in an
exit status of 4.  This can be useful when
.B rca
is used non-interactively.  (Once given,
.B errorexit
cannot be rescinded.)

.SH SHELL SUPPORT
.B rca
can take initial input from the command line, and returns a reasonable
set of exit codes on either success or failure, so incorporating it
into the shell is straightforward:
\" CODE/ENDCODE preserve text verbatim
.de CODE
.br
.nr saveIN \\n(.i   \" double the backslash when defining a macro
.RS
.nf
.nh
..
.de ENDCODE
.hy
.fi
.RE
.in \\n[saveIN]u    \" 'u' means 'units': do not scale this number
..
.CODE

# This shell snippet gives simple access to rca's floating point
# capability from a POSIX shell.
#
# After including this code, use lines like this to calculate:
#       foo=$(fe "$bar * pi")
# or like this for a conditional:
#       if fc "(10 * 3) < $foo"; then ...
#
# Set common initial conditions:
# 3 decimal places, no commas, fail on error
export RCA_INIT="3K commas errorexit"

_rca_run()    # support routine
{
    output=$(rca "( $* )" q)
    exitcode=$?

    if [ $exitcode -le 1 ]; then
        echo $output
        return $exitcode
    fi

    echo rca failure: $output >&2
    exit 1
}

fe()    # Evaluate a floating point expression.
{
    _rca_run "$*"
    return 0
}

fc()     # Evaluate a floating point conditional expression.
{
    _rca_run "$*" >/dev/null
}

.ENDCODE


.SH AUTHOR
Paul Fox created
.B rca
(formerly called "ca") very slowly over a span of decades, starting in 1993.

