.TH rca 1 VERSIONSTRING
.SH NAME
rca \- a rich/RPN (and more) programmer's calculator
.SH SYNOPSIS
.BR rca
.I [ initial rca command text ]

.SH DESCRIPTION
.B rca
is a command-line reverse polish notation (RPN) calculator loosely
inspired by the long line of Hewlett-Packard scientific calculators.
Operators include scientific, logical, and bitwise operations.
.B rca
can also evaluate traditional infix (parenthesized) expressions,
greatly expanding its usefulness.  As a programmer's calculator, word
width can be adjusted to emulate the arithmetic of any class of CPU.
.B rca
can also be easily incorporated into shell scripts to provide floating point
support.

Whitespace in
.BR rca 's
input is often optional, though some cases will cause ambiguity.
Any text following (and including) a
.B #
character is ignored as a comment.

The value at the top of the stack can be shown with the
.B p
command, and the entire stack with
.BR P .
Autoprinting will print the top of the stack after every input line.  This
is on by default; it can be toggled off with
.B 0 autoprint
(or
.B 0
.BR a ).

If
.B rca
is built with the readline library, then command line editing, command
history, and command completion are available.

.SH REVERSE POLISH NOTATION
Numbers entered by the user are pushed onto a stack.  An operator pops
those stack entries, usually 1 or 2 at a time, and pushes the result of
the operation back on the stack.  There are operators for the
usual arithmetic operations
.RB ( + ,
.BR - ,
etc),
functions
.RB ( sin ,
.BR cos ,
.BR sqrt ,
etc),
bit-shifting and manipulation
.RB ( << ,
.BR >> ,
.BR & ,
.BR | ,
etc),
logical operations
.RB ( && ,
.BR || ),
and comparators
.RB ( == ,
.BR !=,
.BR <=,
etc).  There are also unit conversions available (e.g.,
.BR i2mm ,
.BR oz2g ,
.BR f2c ,
and more).
A complete list of operators can be obtained with the
.B help
(or
.BR ? )
command.  The top two elements on the stack, in HP tradition, are
sometimes referred to in the documentation as
.I x
and
.IR y ,
but not literally within the program itself, with one exception:  the
.B lastx
or (
.BR lx )
operator returns the value that was at the top of stack just previous to the
most recently executed operator.

.SH INFIX NOTATION
.B rca
supports infix (i.e., traditional, normal) expressions.  Such
expressions must be fully enclosed in parentheses, and cannot cross to
a new line.  (Infix expressions are translated to RPN by an
implementation of Dijkstra's "shunting yard" algorithm, and then
executed as usual.) A single line of input can be a mix of RPN
notation (unparenthesized) and complete infix expressions
(parenthesized).  The infix expressions "escape" the RPN model, and
are evaluated with fairly typical rules of precedence (see
.B OPERATOR PRECEDENCE
below).  All input number formats are accepted in infix, just as in RPN.
.P
All
.B rca
stack operators can be used as infix functions, including
the unary operators (i.e.,
.BR - x
.BR + x
.BR ~ x
.BR ! x),
and all of the comparison,
logical, and bitwise operators.  Infix expressions result in a value pushed
onto the stack.  For
example, the expression
.B (-3 + +5)
will result in "2" being pushed
on the stack.  When single operand operators appear in infix expressions, the
operand will always follow the operator.  With two operand operators,
one operand will appear on either side of the operator.  So exponentiation
would be written as
.B ( 3 ** 2 )
(producing 9 as a result) and
.B (0 setb 3)
will give 8.  The expression
.B (sin 180 == cos 90)
has the value 1, i.e. "true".
.P
The
.B lastx
(or
.BR lx )
operator can be used in an infix expression.  It returns the value of
.I x
(the top of stack) prior to the expression being invoked.
The five off-stack storage locations can only be set in RPN mode (using
.B store
or
.B s1
through
.BR s5 ),
but are accessible from infix using
.B recall
or
.B r1
through
.BR r5 .
.P
If an error occurs during evaluation of an infix expression,
evaluation will cease, and the stack will be left as it was at the
point of the error.
.SH OPERATING MODES
.B rca
can be configured into two modes of operation:  floating point (the default)
using the
.B F
command, and integer, using one of
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).

The difference between the various integer modes lies mainly in how
values are displayed by default, but floating point differs
in a few additional ways.  Most math is done in long double,
regardless of mode, but in integer mode all stack values are masked to
the current word width, and sign extended, if necessary.

The input base of a number is independent of the mode, and controlled
entirely by how it is entered:  10, 0xa, 012, 0b1010 and 1e01 are all
the same value.  The mode does not affect input:  for example, hex
values must include the "0x" prefix even in
.B H
mode.)

.SS Floating point
In floating point mode (i.e.,
.B F
mode, all operations use the full size of long double.  Printing can
be controlled by either the
.B precision
.RB ( k )
command (which specifies a number of digits for the printf "%g" format), or
by the
.B decimals
.RB ( K )
command (which specifies the number of decimals for the printf "%f"
format).  So the value of pi multiplied by 1 million will display as
3.14159e+06 with
.B 6 k
or as 3,141,592.6535898 with
.B 7
.BR K .

Scientific notation (e.g., 1e09) will be used in
.B precision
mode when the
exponent is less than -4, or greater than the chosen precision.  (These
cutoffs come from directly from printf.)
.B rca
will try to prevent you from printing with more than the available
significant digits on the system:  the default
.B precision
value is set based on this limit (18 digits for most modern PC
architectures), and can't be raised above it.  However, if viewing %f
output (by choosing a
.B decimals
value), it's easy to start seeing "unclean" bits if the magnitude of
the number grows beyond the number of significant digits.  The numbers
are really big at that point:  over 1e19 on a modern system.  Use
.BR precision 's
%g in those cases, which will hide insignificant digits.

Because digital floating point is inexact, values are sometimes
calculated which are
.I almost
correct (like .99999999999... instead of 1), but not quite.
.B rca
tries to help by "snapping" values that are very close to integers to
those integers, and by rounding when the precision limits of the
floating point representation are reached.

.SS Integer
Integer mode is selected with any of the following commands, which
also choose the default display format:
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).
The default printing format is used by
the
.BR p ,
.BR P ,
and
.B autoprint
commands.
Regardless of the default format, individual values can be
viewed at any time in any format by using
.BR f ,
.BR d ,
.BR u ,
.BR h ,
.BR o ,
or
.BR b .

By default the width of
.BR rca 's
integers is the maximum supported, but it can be configured to as
few as 2 bits using the
.B width
(or
.BR w )
command.  Requesting a width of 0 will choose the maximum width.  The
maximum supported width will be either the width of the
.I long long
data type, or of the
.I long double
mantissa, whichever is smaller.  This results in 64 bits on most PC
architectures in 2025.  Two counter-examples:  The Raspberry Pi 3 has
just 52 bits of long double mantissa, so
.BR rca 's
maximum integer width there is limited to 52, at least
on a 32 bit OS.  The Raspberry Pi 4 supports 128-bit "quad-precision"
floats with 113 bits of mantissa, so
has excellent floating point accuracy:  about 33 decimal digits.
But integers in
.B rca
are still limited to the largest native integer
size, 64 bits.)

Values will be masked to the current word width for both
use and display, whether they are input by the user or result from an
operation.  Arithmetic on all values will be signed.  If floating
operations are used on width-restricted integers, the width
restriction will be ignored for the operation, but masking will happen
when storing the result.

.SS Numeric separators
.B rca
can add commas (or the locale's "thousands separator") to group the
numbers it prints.  These separators can be toggled on or off with
.BR 0 / 1
.B s
(or
.BR separators ).
Separators will never appear in the fractional part of a value.  The
separators are strictly cosmetic, based on the printed digits.  No
bitwise splitting (e.g., into bytes) is implied.

Numeric grouping will not be functional if the locale doesn't define
a thousands separator.  Also, numeric grouping may not be functional if
.B rca
is built with libraries other than glibc.  (In that case the
.B separators
command will be missing entirely.)

On input, the locale's currency symbol and thousands separator will be
ignored, as a convenience for doing arithmetic on copy/pasted data.
If the locale isn't configured, then for this purpose only these
symbols will be set to defaults of '$', and ',', respectively.

.SH SPECIAL VALUES
The
.B pi
and
.B e
operators push the obvious constants onto the stack.

The
.B s1
through
.B s5
operators copy
.I x
to one of 5 off-stack storage locations (without
disturbing the stack).  The
.B r1
through
.B r5
operators recall those values, pushing them onto the stack, and can
also be used in infix expressions to reference those values.
.RB ( store
is synonymous with
.BR s1 ,
and
.B recall
with
.BR r1 .)

.SH CONFIGURATION
.B rca
doesn't read a configuration file on startup.  Instead,
commands are read from the environment variable
.BR RCA_INIT ,
and from any command line arguments.  Initial conditions can be
established by either of those methods.  Printed output from
commands run from $RCA_INIT is suppressed.

The commands that control
.BR rca 's
operation and appearance have all been fully described elsewhere, but a concise
list may be useful:
.RS
.P

.BR F ,
.BR D ,
.BR U ,
.BR H ,
.BR O ,
and
.B B
choose float or integer, and the default output base. (Startup:
.BR F )
.P
.B precision
(or
.BR k )
chooses "significant digits" output, and how many. (Startup: 6)
.P
.B decimals
(or
.BR K )
chooses "decimal places" output, and how many.
.P
.B width
(or
.BR w )
chooses the size of integers, in bits. (Startup: system maximum, likely 64).
.P
.B degrees
toggles whether degrees are used by the trig functions, instead of
radians.  (Startup:  enabled)
.P
.B separators
(or
.BR s )
toggles whether output will include separators (usually ',', but
see the LOCALE section) for readability.  (Startup: enabled)
.P
.B autoprint
(or
.BR a )
toggles printing the top of stack after every newline.  (Startup: enabled)
This output is suppressed if the most recent action
explicitly set that value.
.P
.B errorexit
forces
.B rca
to exit on any subsequent error.  Normally errors which result from
user input are reported, but operation continues.
.RE

All of the listed commands will print a confirmation message, but to
avoid confusion, that message will only print if the command is the
last on its line of input.

.SH HELP
The
.B help
or
.B ?
gives a complete list of operators/commands.
If $PAGER is set in the environment, the shell command it names will
be used to display the help text.  (The command must read the text
from standard input.) Otherwise the text will be output directly to the
terminal.

The
.B state
command will print a verbose summary of
.BR rca 's
current state.

.SH OPERATOR PRECEDENCE
Infix evaluation depends on operator precedence and associativity.
The
.B precedence
command lists the operators by decreasing precedence.  The 'R'
flag denotes those which are right associative.  All others group
left to right.  (This list has no meaning for RPN.)

 \fR 1    \fB (
 \fR 2  R \fB sin cos tan asin acos atan atan2 exp ln log2 log10
 \fR      \fB recip sqrt abs frac int i2mm mm2i ft2m m2ft mi2km km2mi
 \fR      \fB oz2g g2oz oz2ml ml2oz q2l l2q d2r r2d f2c c2f
 \fR 3  R \fB + - \fR   (unary)
 \fR 4  R \fB ~ chs negate nop !
 \fR 5  R \fB ^ **
 \fR 6    \fB * x / %
 \fR 7    \fB + -
 \fR 8    \fB >> <<
 \fR 9    \fB & clearb
 \fR 10   \fB xor
 \fR 11   \fB | setb
 \fR 12   \fB < <= > >=
 \fR 13   \fB == !=
 \fR 14   \fB &&
 \fR 15   \fB ||

.SH OPERATOR NOTES
Most operators behave as they are commonly understood to.  A few need
more specific documentation.
.RS
.P
In
.BR rca 's
infix expressions, exponentiation
.RB ( ^
or
.BR ** )
is right associative, and has lower
precedence than unary minus.  Each of these lines returns a result
of 1 (true):
.RS
.P
.B ((2 ^ 3 ^ 2) == (2 ^ (3 ^ 2)))
.I # i.e., 512
.P
.B ((-3 ^ 2) == ((-3) ^ 2)))
.I # i.e., 9
.RE

.P
.B modulo
is a floating point operation, not integer.  It uses the C fmodl() library.
.P
.B frac
applied to negative values will give a negative result.
.P
In an infix expression, operators with two arguments expect
them to the left and right.  This is intuitive for
symbolic operators (as in
.B 1 + 2
), but for named
operators it can look odd.
.B (0xf0 setb 3
.BR ) ,
for example,
sets bit 3 in 0xf0.
.B atan2
works similarly.  This expression:
.B (sin 30 atan2 cos 30)
could also be written as
.B ((sin 30) atan2 (cos 30))
and will evaluate to "30".  (In RPN, this would be
.B 30 sin 30 cos
.BR atan2 .)
.P
The trigonometric functions
.RB ( sin ,
.BR cos ,
.BR tan ,
.BR asin ,
.BR acos ,
.BR atan ,
and
.BR atan2 )
take and return angles in degrees by default.
.B 0 degrees
will switch them to radians, and
.B 1 degrees
will switch them back.  Also, the
.BR deg2rad / rad2deg
operators convert the angle units directly.
Trig operations aren't allowed in integer mode, since they'd make no sense.
.P
Bitwise operations
.RB ( ~
.BR << ,
.BR >> ,
.BR & ,
.BR | ,
.BR xor ,
.BR clearb ,
.B and
.BR setb )
convert their operands to integer first, regardless of mode.  These
operations will (as might be expected) discard fractional parts, and
may discard significant digits, including the sign of the value.  Bitwise
operations will not execute, and cause an error, if either operand
will not fit in a
.I long
.IR long .
.P
.B sum
(or
.BR avg )
will pop and add (or add and then average) previous entries on the
stack, stopping when the stack is empty, or when a stack marker
previously set with the
.B mark
command is reached.
The mark would be set before entering the data for a subsequent
.B sum
(or
.BR avg ),
in order to limit its reach.
.B N mark
(i.e., a
.B mark
command with an argument of
.BR N )
will cause a later
.B sum
(or
.BR avg )
to include the current top N values,
plus any more values that have been pushed prior to the sum.
N cannot be greater than the length of the stack.
.RB " 0
.BR mark "
will cause only subsequent pushes to be summed/averaged.
.RB " -1
.BR mark "
will clear the mark.
.B sum
and
.B avg
are the only operators to consume more than 2 stack elements.
.RE

.SH LOCALE
The locale is consulted for just three things.
.P
The locale chooses the decimal point.  Usually this is '.', but
is also commonly ','.
.P
If the locale defines a thousands separator, it will be used for
numeric grouping, and will be ignored during input.  If the locale
doesn't define a thousands separator, there will be no numeric grouping.
.P
If the locale defines a currency symbol, and its value doesn't
match the name of any
.B rca
command, it will be ignored on input.
If the locale doesn't define a currency symbol, it will be set to
"$", and ignored on input.
.SH DATA TYPES, OVERFLOW, ACCURACY
All stack values in
.B rca
are stored in
.I long double
format.  This is convenient for a calculator
which will primarily deal with floating point, but can affect
.BR rca 's
mixed model.  Changing
.BR rca 's
operating mode from floating point to an integer mode
requires conversion of all stack values
to integer.
If the conversion from
.I long double
to
.I long long
can't be done without loss, a error message is issued, but the
conversion has already occurred, and the loss cannot be undone.  If
simply displaying a float value as integer, without changing modes,
then the original value is unchanged.  Execution will proceed after
the warning unless
.B errorexit
has been enabled.

Some floating point operations give results which are invalid ("nan",
i.e., "not a number") or "+inf" or "-inf" (i.e., infinity).  When
converting to integer mode, these values will be preserved, along with
their semantics:  any computation involving nan will return nan, and
any conditionals involving nan will return false.
.B rca
doesn't distinguish between mathematical poles (e.g., the value of
"tan(pi/2)") and overflow conditions (very large finite values that
could be represented, if only you'd bought a better calculator).  Both
show as "+/-inf".

Floating point math by its nature is imprecise.  It's not uncommon for
small rounding errors, and errors introduced by the necessary binary
to decimal conversions, to change values in obvious ways.  Something
that should be 0 may instead have a very tiny value, or two numbers which
should be equal may differ by an insignificant amount.
.B rca
attempts to help by adjusting values pushed on the stack.  First,
values within about 2e-18 (system dependent) of an integer are forced
to that integer.  Then, values are decimal-rounded to
.BR rca 's
maximum precision (again, usually 18 digits).

.SH EXIT STATUS
.B rca
will normally exit with status 0 or 1.  To satisfy normal shell
boolean logic semantics, the exit status will be 0 if the top of stack
is non-zero, and 1 if the top of stack is 0.
A normal exit with an empty stack causes an exit status of 2.
Unrecoverable internal errors (e.g., failed memory allocation) cause
an exit status of 3.
Errors resulting from user input (parsing errors, empty stack, data
conversion warnings) are non-fatal unless the
.B errorexit
toggle has been set.
In that case, those warnings and errors will cause
exit status of 4.  This can be useful when
.B rca
is used non-interactively.

.SH SHELL SUPPORT
Incorporating
.B rca
into the shell is straightforward:

\" create CODE/ENDCODE macros to preserve text verbatim
.de CODE
.br
.nr saveIN \\n(.i   \" double the backslash when defining a macro
.RS
.nf
.nh
..
.de ENDCODE
.hy
.fi
.RE
.in \\n[saveIN]u    \" 'u' means 'units': do not scale this number
..

.CODE

# This shell snippet gives simple access to rca's floating point
# capability from a POSIX shell.
#
# After including this code, use lines like this to calculate:
#       foo=$(fe "$bar * pi")
# or like this for a conditional expression:
#       if fc "(10 * 3) < $foo"; then ...
#
# Use RCA_INIT to set common initial conditions.  Defaults are
# provided here, but values set externally will override.

export RCA_INIT="3decimals 0separators 1errorexit ${RCA_INIT:-}"

_rca_run()    # support routine
{
    local output=$(rca "( $* )" q)
    local exitcode=$?

    case $exitcode in
    0|1)
        echo $output
        return $exitcode ;;
    esac

    echo rca failure: $output >&2
    exit $exitcode
}

fe()    # Evaluate a floating point expression.
{
    _rca_run "$*"
    return 0
}

fc()     # Evaluate a floating point conditional expression.
{
    _rca_run "$*" >/dev/null
}

.ENDCODE


.SH AUTHOR
Paul Fox created
.B rca
(formerly called "ca") very slowly over a span of decades, starting in 1993.

