.TH rca 1 VERSIONSTRING
.SH NAME
rca \- a rich/RPN (and more) programmer's calculator
.SH SYNOPSIS
.BR rca
.I [ initial rca command text ]

.SH DESCRIPTION
At it's heart,
.B rca
is a command-line reverse polish notation (RPN) calculator inspired
(very loosely) by the long line of Hewlett-Packard scientific
calculators.  Operators include scientific, logical, and bitwise
operators.  In addition,
.B rca
can evaluate traditional infix expressions, greatly expanding its
usefulness.  As a programmer's calculator, word width can be limited,
for emulating the operation of any class of CPU.  Input is free form,
for the most part, and
.B rca
is easily incorporated into shell scripts to provide floating point
support.  Whitespace is usually optional, though there may be cases
where ambiguity would get in the way.  Any text including and
following a
.B #
character will be ignored as a comment.

The value at the top of the stack can be shown with the
.B p
command, and the entire stack with
.BR P .
Autoprinting (toggled on with
.B 1 a
(or
.B 1
.BR autoprint )
will print the top of the stack after every input line.

.SH REVERSE POLISH NOTATION
Numbers entered by the user are pushed onto a stack.  Operators pop
those stack entries, usually 1 or 2 at a time, and push the result of
the operation back on the stack.  Operators exist which cover the
usual arithmetic operations
.RB ( + ,
.BR - ,
etc),
functions
.RB ( sin ,
.BR cos ,
.BR sqrt ,
etc),
bit-shifting and manipulation
.RB ( << ,
.BR >> ,
.BR & ,
.BR | ,
etc),
logical operations
.RB ( && ,
.BR || ),
and comparators
.RB ( == ,
.BR !=,
.BR <=,
etc).  There are also unit conversions available (e.g.,
.BR i2mm ,
.BR oz2g ,
.BR f2c ,
and more).
A complete list of operators can be obtained with the
.B ?
or
.B help
commands.  The top two elements on the stack, in HP tradition, are
sometimes referred to as
.I x
and
.IR y .

.SH INFIX NOTATION
.B rca
supports infix (i.e., traditional, normal) style expressions.  Such
expressions must be fully enclosed in parentheses, and cannot cross to
a new line.  (Infix expressions are translated to RPN by an
implementation of Dijkstra's "shunting yard" algorithm, and then
executed as usual.) A single line of input can be a mix of RPN
notation (unparenthesized) and complete infix expressions
(parenthesized).  The infix expressions "escape" the RPN model, and
are evaluated with fairly typical rules of precedence (see
.B OPERATOR PRECEDENCE
below).  All input number formats are accepted in infix, just as in RPN.
.P
All
.B rca
stack operators can be used as infix functions, including
the unary operators (i.e.,
.BR - x
.BR + x
.BR ~ x
.BR ! x),
and all of the comparison,
logical, and bitwise operators.  Infix expressions result in a value.  For
example, the expression
.B (-3 + +5)
will result in "2" being pushed
on the stack.  When single operand operators appear in infix expressions, the
operand will always follow the operator.  With two operand operators,
one operand will appear on either side of the operator.  So exponentiation
would be written as
.B ( 3 ** 2 )
(producing 9 as a result) and
.B (0 setb 3)
will give 8.  The expression
.B (sin 180 == cos 90)
has the value 1, i.e. "true".
.P
The special symbol
.B X
can be used in an infix expression to reference the value of
.I x
(the top of stack) when the expression was invoked.  (The top of
stack will
.I not
be popped or replaced.) The five off-stack storage locations settable (only in
RPN mode) with
.B store
or
.B s1
through
.B s5
can also be
accessed, by referencing
.B r1
through
.BR r5 .
.P
If an error occurs during evaluation of an infix expression,
evaluation will cease, and the stack will be left as it was at the
point of the error. 
.SH OPERATING MODES
.B rca
can be configured into two modes of operation:  floating point (the default)
using the
.B F
command, and integer, using one of
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).

The difference between the various integer modes lies purely in how
values are displayed by default, but floating point and integer differ
in a few additional ways.  Most math is done in long double, regardless
of mode, but in integer mode all stack values are masked to the
current word width, and sign extended, if necessary.

The input base of a number is independent of the mode, and controlled
entirely by how it is entered:  10, 0xa, 012, 0b1010 and 1e01 are all
the same value.

.SS Floating point
In floating point mode (i.e.,
.B F
mode, all operations use the full size of long double.  Printing can
be controlled by either the
.B precision
.RB ( k )
command (which specifies a number of digits for the printf "%g" format), or
by the
.B decimals
.RB ( K )
command (which specifies the number of decimals for the printf "%f"
format).  So the value of pi multiplied by 1 million will display as
3.14159e+06 with
.B 6 k
or as 3,141,592.6535898 with
.B 7
.BR K .

Scientific notation (e.g., 1e09) will be used in
.B precision
mode when the
exponent is less than -4, or greater than the chosen precision.  (These
cutoffs come from directly from printf.)
.B rca
will try to prevent you from printing with more than the available
significant digits on the system:  the default
.B precision
value is set based on this limit (18 digits for most modern PC
architectures), and can't be raised above it.  However, if viewing %f
output (by choosing a
.B decimals
value), it's easy to start seeing "unclean" bits if the magnitude of
the number grows beyond the number of significant digits.  The numbers
are really big at that point:  over 1e19 on a modern system.  Use
.BR precision 's
%g in those cases, which will hide insignificant digits.

Because digital floating point is inexact, values are sometimes
calculated which are
.I almost
correct (like .99999999999... instead of 1), but not quite.
.B rca
tries to help by "snapping" values that are very close to integers to
those integers, and by rounding when the precision limits of the
floating point representation are reached.

.SS Integer
Integer mode is selected with any of the following commands, which
also choose the default display format:
.B D
(signed decimal),
.B U
(unsigned decimal),
.B H
(hex),
.B O
(octal), or
.B B
(binary).
The default printing format is used by
the
.BR p ,
.BR P ,
and
.B autoprint
commands.
Regardless of the default format, individual values can be
viewed at any time in any format by using
.BR f ,
.BR d ,
.BR u ,
.BR h ,
.BR o ,
or
.BR b .

By default the width of
.BR rca 's
integers is the maximum supported, but it can be configured to as
few as 2 bits using the
.B width
(or
.BR w )
command.  The maximum supported width will be either the width of the
.I long long
data type, or of the
.I long double
mantissa, whichever is smaller.  This results in 64 bits on most PC
architectures in 2025.  (An exception:  52 bits on Raspberry Pi
when running a 32 bit OS)

Values will be masked to the chosen word width for both
use and display, whether they are input by the user or result from an
operation.  Arithmetic on all values will be signed.  If floating
operations are used on width-restricted integers, the width
restriction will be ignored for the operation, but masking will happen
when storing the result.

.SS Punctuation
To aid in reading long digit strings,
.B rca
can add commas to numbers it prints.  These can be toggled on or off
with
.BR 0 / 1
.B c
(or
.BR commas ).
Commas will never appear in the fractional part of a value.

Both commas and the "$" currency symbol will be silently stripped on
input, as a convenience for doing arithmetic on copy/pasted data.

.SH SPECIAL VALUES
The
.B pi
and
.B e
operators push the values of the obvious constants to the stack.

The
.B s1
through
.B s5
operators copy
.I x
to one of 5 off-stack storage locations (without
disturbing the stack).  The
.B r1
through
.B r5
operators recall those values, pushing them onto the stack, and can
also be used in infix expressions to reference those values.
.RB ( store
is synonymous with
.BR s1 ,
and
.B recall
with
.BR r1 .)

.SH CONFIGURATION
A few commands/pseudo-operators control aspects of
.BR rca 's
operation and appearance:
.RS
.P
The
.BR F ,
.BR D ,
.BR U ,
.BR H ,
.BR O ,
and
.B B
commands select float or integer operation, along with the default
base for output.
.B rca
starts in
.B F
mode.
.P
.B precision
(or
.BR k )
selects %g format for floating point output (e.g.,
"1.2345e+09"), along with the number of significant digits.
This format is selected on startup, with 6 significant digits.
.P
.B decimals
(or
.BR K )
selects %f format for floating point output (e.g.,
"1,234,500,000.00") along with the number of decimals after the point.
.P
.B width
(or
.BR w )
selects the word width used in integer mode.  The startup default
is the system maximum (likely 64).
.P
.B commas
(or
.BR c )
toggles whether printed
values will include comma characters for readability.  This is
enabled by default.  The command's argument is 0 or non-zero.
.P
.B degrees
toggles whether the trigonometric functions work with degrees or
radians.  Degrees are selected when
.B rca
starts.  The argument is 0 or non-zero.
.P
.B autoprint
(or
.BR a )
toggles whether
.B rca
will print the value at the top of stack after every newline.  This
printing will be suppressed if the last action on the previous line
explicitly set that value, since to print it again immediately would
be redundant.  Automatic printing is selected when
.B rca
starts.  The argument is 0 or non-zero.
.RE

All of the listed commands will print a confirmation message, but to
avoid confusion, that message will only print if the command is the
last on its line of input.

.B rca
doesn't have a configuration file that's read on startup.  It does,
however, take commands from the environment variable
.BR RCA_INIT ,
and from any arguments passed on the command line.  So initial
conditions can be established by either of those methods.  All printed
output from commands run from $RCA_INIT is suppressed.

.SH HELP
A complete list of operators/commands can be obtained by entering
.B help
or
.BR ? .
Many operators have two names, and this is indicated in the command
listing.  If $PAGER is set in the environment, it will be invoked to
display the help text.  Otherwise the text will be shown directly
to the terminal.

.SH OPERATOR PRECEDENCE
When used as an RPN calculator, operator precedence isn't 
meaningful, since the stack paradigm makes all operators equal in that
regard.  But when evaluating an infix expression, the relative
precedence and associativity of operators is important.  The
.B precedence
command will give a list, whose output is reproduced
here.  Higher numbers denote higher precedence.  The 'R' flag denotes
operators which are right associative.  All others group left to
right.

 \fR 1      \fB (
 \fR 2   R  \fB atan2 recip sqrt sin cos tan asin acos atan ln log2 log10
 \fR        \fB   abs frac int i2mm mm2i ft2m m2ft mi2km km2mi f2c c2f
 \fR        \fB   oz2g g2oz oz2ml ml2oz q2l l2q
 \fR 3   R  \fB + - \fR   (unary)
 \fR 4   R  \fB ~ chs negate !
 \fR 5   R  \fB ^ **
 \fR 6      \fB * x / %
 \fR 7      \fB + -
 \fR 8      \fB >> <<
 \fR 9      \fB & clearb
 \fR 10     \fB xor
 \fR 11     \fB | setb
 \fR 12     \fB < <= > >=
 \fR 13     \fB == !=
 \fR 14     \fB &&
 \fR 15     \fB ||

.SH OPERATOR NOTES
Most operators behave as they are commonly understood to.  A few need
more specific documentation.
.RS
.P
The precedence and association of exponentiation
.RB ( ^
or
.BR ** )
is worth calling out,
since implementations vary.  In
.BR rca 's
infix expressions,
exponentiation is right associative, and has lower precedence than unary minus.
So each of these lines returns a result of 1 (true):
.RS
.P
.B ((2 ^ 3 ^ 2) == (2 ^ (3 ^ 2)))
.I # i.e., 512
.P
.B ((-3 ^ 2) == ((-3) ^ 2)))
.I # i.e., 9
.RE

.P
.B modulo
is a floating point operation.  It uses the C fmodl() library.
.P
.B frac
applied to negative values will give a negative result.
.P
In an infix expression, any operator that takes two arguments expects
them to be to the left and right of the operator.  This is expected in
the case of the symbolic operators (as in
.B 1 + 2
), but for the named
operators it can be odd looking.  
.B (0xf0 setb
.BR 3 ),
for example,
sets bit 3 in 0xf0.
.B atan2
works similarly:
.B (sin 30 atan2 cos 30)
could also be written as
.B ((sin 30) atan2 (cos 30))
and will return the result "30".  (In RPN, this would be
.B 30 sin 30 cos
.BR atan2 .)
.P
Trigonometric operations
.RB ( sin ,
.BR cos ,
.BR tan ,
.BR asin ,
.BR acos ,
.BR atan ,
and
.BR atan2 )
are disallowed in integer mode, since they'd make no sense.
By default the trig functions take and return angles in degrees.  The
.B 0 degrees
toggle command will switch them to radians.
.B 1 degrees
will switch them back.
.P
Bitwise operations
.RB ( ~
.BR << ,
.BR >> ,
.BR & ,
.BR | ,
.BR xor ,
.BR clearb ,
.B and
.BR setb )
convert their operands to long long first, regardless of mode.  These
operations will (as might be expected) discard fractional parts, and
may discard significant digits, including the sign of the value.
.P
.B sum
will pop and add up previous entries on the
stack, stopping when the stack is empty, or when a
stack marker previously set with the
.B mark
command is reached.
The mark would be set before entering the data for a subsequent
.BR sum,
in order to limit its reach.
.B sum
is the only operator to consume more than 2 stack elements.

.SH DATA TYPES, OVERFLOW, ACCURACY
All stack values in
.B rca
are stored in
.I long double
format.  This is convenient for a calculator
which will primarily deal with floating point, but can be a problem with
.BR rca 's
mixed model.  Many operations (primarily the bitwise operations, but
also simply working in other bases and word widths) require conversion
to integer.  The
.I long long
type is used in this case; results are
converted back when finished.  If the conversion from
.I long double
to
.I long long
can't be done without loss, a warning is
issued.  This may happen while printing the value in an integer base,
after switching to an integer mode, or while performing a bitwise
operation.  Execution will proceed after the warning unless
.B errorexit
has been enabled.

Floating point math by its nature is imprecise.  It's not uncommon for
small rounding errors, and errors introduced by the necessary binary
to decimal conversions, to change values in obvious ways.  Something
that should be 0 may instead have a very tiny value, or two numbers which
should be equal may differ by an insignificant amount.
.B rca
attempts to help by adjusting values pushed on the stack.  First,
values within about 2e-18 (system dependent) of an integer are forced
to that.  integer.  Then, values are decimal-rounded to
.BR rca 's
maximum precision (again, usually 18 digits).

.SH EXIT STATUS
.B rca
will normally exit with status 0 or 1:  to satisfy normal shell
semantics, a non-zero value at the top of the stack causes an
exit status of 0, and vice versa.  An exit status of 2 results if the
stack is empty on normal exit.  An exit status of 3 comes from
unrecoverable internal errors (e.g., failed memory allocation). 
Operational warnings or errors regarding parsing, empty stacks, or
data conversion are assumed be useful to the user, and non-fatal.  If
the
.B errorexit
command has been given, then those warnings and errors will result in an
exit status of 4.  This can be helpful when
.B rca
is used non-interactively.  (Once given,
.B errorexit
cannot be rescinded.)

.SH SHELL SUPPORT
.B rca
can take initial input from the command line, and returns a helpful
set of exit codes, so incorporating it into the shell is straightforward:

\" create CODE/ENDCODE macros to preserve text verbatim
.de CODE
.br
.nr saveIN \\n(.i   \" double the backslash when defining a macro
.RS
.nf
.nh
..
.de ENDCODE
.hy
.fi
.RE
.in \\n[saveIN]u    \" 'u' means 'units': do not scale this number
..

.CODE

# This shell snippet gives simple access to rca's floating point
# capability from a POSIX shell.
#
# After including this code, use lines like this to calculate:
#       foo=$(fe "$bar * pi")
# or like this for a conditional:
#       if fc "(10 * 3) < $foo"; then ...
#
# Set common initial conditions.  Values previously set will override.
# 3 decimals , no commas, fail on error.
export RCA_INIT="3K 0commas errorexit ${RCA_INIT:-}"

_rca_run()    # support routine
{
    output=$(rca "( $* )" q)
    exitcode=$?

    case $exitcode in
    0|1)
        echo $output
        return $exitcode ;;
    esac

    echo rca failure: $output >&2
    exit $exitcode
}

fe()    # Evaluate a floating point expression.
{
    _rca_run "$*"
    return 0
}

fc()     # Evaluate a floating point conditional expression.
{
    _rca_run "$*" >/dev/null
}

.ENDCODE


.SH AUTHOR
Paul Fox created
.B rca
(formerly called "ca") very slowly over a span of decades, starting in 1993.

